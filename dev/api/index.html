<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · LegendOpticalFits</title><meta name="title" content="API · LegendOpticalFits"/><meta property="og:title" content="API · LegendOpticalFits"/><meta property="twitter:title" content="API · LegendOpticalFits"/><meta name="description" content="Documentation for LegendOpticalFits."/><meta property="og:description" content="Documentation for LegendOpticalFits."/><meta property="twitter:description" content="Documentation for LegendOpticalFits."/><meta property="og:url" content="https://legend-exp.github.io/LegendOpticalFits.jl/stable/api/"/><meta property="twitter:url" content="https://legend-exp.github.io/LegendOpticalFits.jl/stable/api/"/><link rel="canonical" href="https://legend-exp.github.io/LegendOpticalFits.jl/stable/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LegendOpticalFits</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Modules"><span>Modules</span></a></li><li><a class="tocitem" href="#Types-and-constants"><span>Types and constants</span></a></li><li><a class="tocitem" href="#Functions-and-macros"><span>Functions and macros</span></a></li><li class="toplevel"><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li></ul></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/legend-exp/LegendOpticalFits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Modules"><a class="docs-heading-anchor" href="#Modules">Modules</a><a id="Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Modules" title="Permalink"></a></h2><ul></ul><h2 id="Types-and-constants"><a class="docs-heading-anchor" href="#Types-and-constants">Types and constants</a><a id="Types-and-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-constants" title="Permalink"></a></h2><ul><li><a href="#LegendOpticalFits.OpticalMap"><code>LegendOpticalFits.OpticalMap</code></a></li></ul><h2 id="Functions-and-macros"><a class="docs-heading-anchor" href="#Functions-and-macros">Functions and macros</a><a id="Functions-and-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-and-macros" title="Permalink"></a></h2><ul><li><a href="#LegendOpticalFits._λ0_model_bulk_ops-Tuple{AbstractVector{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractArray{&lt;:Number, 3}}"><code>LegendOpticalFits._λ0_model_bulk_ops</code></a></li><li><a href="#LegendOpticalFits._λ0_model_loops-Tuple{AbstractVector{&lt;:AbstractFloat}, AbstractMatrix{&lt;:AbstractFloat}, AbstractMatrix{Bool}}"><code>LegendOpticalFits._λ0_model_loops</code></a></li><li><a href="#LegendOpticalFits.analytical_λ0_curve-Tuple{TypedTables.Table, TypedTables.Table, Symbol}"><code>LegendOpticalFits.analytical_λ0_curve</code></a></li><li><a href="#LegendOpticalFits.analytical_λ0_curve_all-Tuple{TypedTables.Table, TypedTables.Table}"><code>LegendOpticalFits.analytical_λ0_curve_all</code></a></li><li><a href="#LegendOpticalFits.ar39_beta_energy_dist-Tuple{}"><code>LegendOpticalFits.ar39_beta_energy_dist</code></a></li><li><a href="#LegendOpticalFits.detection_prob-Tuple{Any, Vararg{Any}}"><code>LegendOpticalFits.detection_prob</code></a></li><li><a href="#LegendOpticalFits.detection_prob_vov-NTuple{4, Any}"><code>LegendOpticalFits.detection_prob_vov</code></a></li><li><a href="#LegendOpticalFits.estimate_efficiencies_from_curves-Tuple{AbstractDict, NamedTuple}"><code>LegendOpticalFits.estimate_efficiencies_from_curves</code></a></li><li><a href="#LegendOpticalFits.load_optical_map-Tuple{AbstractString, Tuple{LegendDataManagement.DataPeriodLike, Union{LegendDataManagement.DataRun, AbstractString, Symbol}}}"><code>LegendOpticalFits.load_optical_map</code></a></li><li><a href="#LegendOpticalFits.log_p0_nominal-Tuple{TypedTables.Table, NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}}"><code>LegendOpticalFits.log_p0_nominal</code></a></li><li><a href="#LegendOpticalFits.log_p0_nominal_ar39-Tuple{NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}, Integer}"><code>LegendOpticalFits.log_p0_nominal_ar39</code></a></li><li><a href="#LegendOpticalFits.make_efficiencies_prior-Tuple{Any}"><code>LegendOpticalFits.make_efficiencies_prior</code></a></li><li><a href="#LegendOpticalFits.make_λ0_likelihood-Tuple{TypedTables.Table, TypedTables.Table, TypedTables.Table}"><code>LegendOpticalFits.make_λ0_likelihood</code></a></li><li><a href="#LegendOpticalFits.rand_voxel-Tuple{NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}}"><code>LegendOpticalFits.rand_voxel</code></a></li><li><a href="#LegendOpticalFits.x0_data-Tuple{AbstractString, Tuple{LegendDataManagement.DataPeriodLike, Union{LegendDataManagement.DataRun, AbstractString, Symbol}}}"><code>LegendOpticalFits.x0_data</code></a></li><li><a href="#LegendOpticalFits.x0_mock-Tuple{NamedTuple, TypedTables.Table, TypedTables.Table}"><code>LegendOpticalFits.x0_mock</code></a></li><li><a href="#LegendOpticalFits.λ0_data-Tuple{TypedTables.Table}"><code>LegendOpticalFits.λ0_data</code></a></li><li><a href="#LegendOpticalFits.λ0_model-Tuple{NamedTuple, TypedTables.Table, TypedTables.Table}"><code>LegendOpticalFits.λ0_model</code></a></li></ul><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="LegendOpticalFits.OpticalMap"><a class="docstring-binding" href="#LegendOpticalFits.OpticalMap"><code>LegendOpticalFits.OpticalMap</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OpticalMap ≡ NamedTuple of 3D histograms keyed by channel Symbol</code></pre><p>Handy type alias for LEGEND optical maps, i.e. three-dimensional histograms for each SiPM channel. The field names are the channel symbols (e.g. :S030).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/optmap.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits._λ0_model_bulk_ops-Tuple{AbstractVector{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractArray{&lt;:Number, 3}}"><a class="docstring-binding" href="#LegendOpticalFits._λ0_model_bulk_ops-Tuple{AbstractVector{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractArray{&lt;:Number, 3}}"><code>LegendOpticalFits._λ0_model_bulk_ops</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_λ0_model_bulk_ops()</code></pre><p>Low-level implementation of <code>λ0_model</code> using bulk array programming, Reactant / CUDA compatible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/models.jl#L57-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits._λ0_model_loops-Tuple{AbstractVector{&lt;:AbstractFloat}, AbstractMatrix{&lt;:AbstractFloat}, AbstractMatrix{Bool}}"><a class="docstring-binding" href="#LegendOpticalFits._λ0_model_loops-Tuple{AbstractVector{&lt;:AbstractFloat}, AbstractMatrix{&lt;:AbstractFloat}, AbstractMatrix{Bool}}"><code>LegendOpticalFits._λ0_model_loops</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_λ0_model_loops()</code></pre><p>Low-level implementation of <code>λ0_model</code> using for loops.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/models.jl#L95-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.analytical_λ0_curve-Tuple{TypedTables.Table, TypedTables.Table, Symbol}"><a class="docstring-binding" href="#LegendOpticalFits.analytical_λ0_curve-Tuple{TypedTables.Table, TypedTables.Table, Symbol}"><code>LegendOpticalFits.analytical_λ0_curve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">analytical_λ0_curve(log_p0_nominal, x0_random_coin, channel; eps_range=range(0.0,1.0,length=101))</code></pre><p>Compute the per-channel no-light probability λ₀ as a function of a single channel&#39;s efficiency. </p><p>This analytical model computes the expectation per event  λ₀<em>jk = mean(p0</em>jk * x0<em>jk) with p0</em>jk = exp(log<em>p0</em>jk * ε) and x0_jk  the random coincidence indicators.</p><p><strong>Arguments</strong></p><ul><li><code>log_p0_nominal::Table</code>: table of log p0 values (events × channels).</li><li><code>x0_random_coin::Table</code>: table of random-coincidence indicators (events × channels).</li><li><code>channel::Symbol</code>: Symbol identifying the channel (must be present in columnnames(log<em>p0</em>nominal)).</li><li><code>eps_range</code>: efficiency values to evaluate (vector or range).</li></ul><p><strong>Returns</strong></p><ul><li><code>NamedTuple</code> with fields :eps (vector of efficiencies) and :λ0 (vector of no-light probabilities evaluated at those efficiencies).</li></ul><p><strong>Notes</strong></p><p>Can only be used if no multiplicity threshold is applied!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/models.jl#L148-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.analytical_λ0_curve_all-Tuple{TypedTables.Table, TypedTables.Table}"><a class="docstring-binding" href="#LegendOpticalFits.analytical_λ0_curve_all-Tuple{TypedTables.Table, TypedTables.Table}"><code>LegendOpticalFits.analytical_λ0_curve_all</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">analytical_λ0_curve_all(log_p0_nominal, x0_random_coin; eps_range=range(0.0,1.0,length=101))</code></pre><p>Compute λ₀(eps) curves for every channel present in <code>log_p0_nominal</code>.</p><p>Description</p><ul><li>For each channel (columns of <code>log_p0_nominal</code>) evaluate the no-light probability λ₀ across <code>eps_range</code> by calling <code>compute_λ0_curve</code>.</li><li>The returned curves are suitable for locating the efficiency at which a measured λ₀ would be reproduced (e.g. by interpolation).</li></ul><p>Arguments</p><ul><li>see above in description of <code>compute_λ0_curve</code></li></ul><p>Returns</p><ul><li><code>Dict{Symbol, NamedTuple}</code> mapping each channel symbol to the NamedTuple returned by <code>compute_λ0_curve</code> (fields <code>:eps</code> and <code>:λ0</code>).</li></ul><p>Notes</p><ul><li>Channel order is derived from <code>columnnames(log_p0_nominal)</code>. Use that table to control which channels are computed and their ordering.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/models.jl#L205-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.ar39_beta_energy_dist-Tuple{}"><a class="docstring-binding" href="#LegendOpticalFits.ar39_beta_energy_dist-Tuple{}"><code>LegendOpticalFits.ar39_beta_energy_dist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ar39_beta_energy_dist() -&gt; MixtureModel{Uniform}</code></pre><p>Energy distribution of the beta particle emitted in an Ar-39 nuclear decay.</p><p>Return a continuous probability distribution for the beta decay spectrum of Ar-39. The distribution is constructed from tabulated values from the IAEA BetaShape database, downloadable at this <a href="https://www-nds.iaea.org/relnsd/v1/data?fields=bin_beta&amp;nuclides=39ar&amp;rad_types=bm">link</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/simulation.jl#L135-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.detection_prob-Tuple{Any, Vararg{Any}}"><a class="docstring-binding" href="#LegendOpticalFits.detection_prob-Tuple{Any, Vararg{Any}}"><code>LegendOpticalFits.detection_prob</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">detection_prob(h, coords...)</code></pre><p>Return the bin content of histogram <code>h</code> at the given coordinates <code>coords</code> (with units). Coordinates must be inside the histogram bounds, otherwise an error is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/optmap.jl#L45-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.detection_prob_vov-NTuple{4, Any}"><a class="docstring-binding" href="#LegendOpticalFits.detection_prob_vov-NTuple{4, Any}"><code>LegendOpticalFits.detection_prob_vov</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">detection_prob_bcast(h, xss, yss, zss)</code></pre><p>Apply [<code>detection_prob_event</code>] to each triple of vectors <code>(xs, ys, zs)</code> from <code>(xss, yss, zss)</code>.</p><p>This is useful when <code>xss</code>, <code>yss</code>, and <code>zss</code> are <code>VectorOfVectors</code>, e.g. the coordinates of all hits for many events. Returns a vector of vectors of bin contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/optmap.jl#L67-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.estimate_efficiencies_from_curves-Tuple{AbstractDict, NamedTuple}"><a class="docstring-binding" href="#LegendOpticalFits.estimate_efficiencies_from_curves-Tuple{AbstractDict, NamedTuple}"><code>LegendOpticalFits.estimate_efficiencies_from_curves</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_efficiencies_from_curves(curves, λ0_d)</code></pre><p>Given a mapping <code>curves</code> from some key (e.g. fiber symbol) to a NamedTuple with fields <code>:eps</code> and <code>:λ0</code> (as produced by <code>λ0_vs_efficiency_all</code> or similar), and a dictionary <code>λ0_d</code> mapping channel symbols to observed no-light probabilities, compute the efficiency at which the simulated curve crosses the observed λ₀ for each channel.</p><p><strong>Arguments</strong></p><ul><li><code>curves::AbstractDict{K,NamedTuple}</code>: maps a key (fiber or channel) to a NamedTuple <code>(eps, λ0)</code> where <code>eps</code> is a vector of efficiencies and <code>λ0</code> the corresponding no-light probabilities.</li><li><code>λ0_d::NamedTuple</code>: observed λ₀ per channel symbol.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{Symbol,Float64}</code> mapping channel symbol -&gt; estimated efficiency.</li></ul><p>The routine finds a bracket where the curve crosses the horizontal line <code>λ0 = λ0_d[channel]</code> and linearly interpolates between neighbouring points. If no sign change is found, it falls back to the nearest sampled point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/inference.jl#L1-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.load_optical_map-Tuple{AbstractString, Tuple{LegendDataManagement.DataPeriodLike, Union{LegendDataManagement.DataRun, AbstractString, Symbol}}}"><a class="docstring-binding" href="#LegendOpticalFits.load_optical_map-Tuple{AbstractString, Tuple{LegendDataManagement.DataPeriodLike, Union{LegendDataManagement.DataRun, AbstractString, Symbol}}}"><code>LegendOpticalFits.load_optical_map</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">load_optical_map(filename, runsel) -&gt; OpticalMap</code></pre><p>Load a LEGEND-200 optical map from file.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">load_optical_map(&quot;./optmap.lh5&quot;, (:p13, :r001))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/optmap.jl#L10-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.log_p0_nominal-Tuple{TypedTables.Table, NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}}"><a class="docstring-binding" href="#LegendOpticalFits.log_p0_nominal-Tuple{TypedTables.Table, NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}}"><code>LegendOpticalFits.log_p0_nominal</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">log_p0_nominal(sim_data, optical_map; ...)</code></pre><p>Logarithm of no-light-probability for events simulated by remage.</p><p>This can be used to compute inputs for <a href="#LegendOpticalFits.λ0_model-Tuple{NamedTuple, TypedTables.Table, TypedTables.Table}"><code>λ0_model</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>sim_data</code>: output table (stepping data) for a scintillation detector (the same the optical map refers to) from remage. Must contain the fields <code>xloc</code>, <code>yloc</code>, <code>zloc</code> and <code>edep</code>.</li><li><code>optmap</code>: liquid argon optical map as loaded by <a href="#LegendOpticalFits.load_optical_map-Tuple{AbstractString, Tuple{LegendDataManagement.DataPeriodLike, Union{LegendDataManagement.DataRun, AbstractString, Symbol}}}"><code>load_optical_map</code></a>.</li><li><code>n_events</code>: number of Ar-39 decays to simulate.</li><li><code>light_yield</code>: liquid argon scintillation yield.</li></ul><p><strong>Returns</strong></p><p>A table of <code>log(p0)</code> for each channel (columns) and event (rows).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># load an optical map
optmap = load_optical_map(&quot;map.lh5&quot;, (:p13, :r001))

# load some remage simulation data
sim_data = lh5open(&quot;th228.lh5&quot;) do h5
    return h5[&quot;stp/lar&quot;][:]
end

# call the function
log_p0_nominal(sim_data, optmap)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/simulation.jl#L1-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.log_p0_nominal_ar39-Tuple{NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}, Integer}"><a class="docstring-binding" href="#LegendOpticalFits.log_p0_nominal_ar39-Tuple{NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}, Integer}"><code>LegendOpticalFits.log_p0_nominal_ar39</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">log_p0_nominal_ar39(optical_map, n_events; ...)</code></pre><p>Logarithm of no-light-probability for simulated Ar-39 events.</p><p>Uses the energy distribution of the beta particle emitted in the decay of an Ar-39 nucleus and the detection probability in liquid argon (through the optical map) to estimate the probability of seeing no light for a set of random events. This can be used to compute inputs for <a href="#LegendOpticalFits.λ0_model-Tuple{NamedTuple, TypedTables.Table, TypedTables.Table}"><code>λ0_model</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>optmap</code>: liquid argon optical map as loaded by <a href="#LegendOpticalFits.load_optical_map-Tuple{AbstractString, Tuple{LegendDataManagement.DataPeriodLike, Union{LegendDataManagement.DataRun, AbstractString, Symbol}}}"><code>load_optical_map</code></a>.</li><li><code>n_events</code>: number of Ar-39 decays to simulate.</li><li><code>light_yield</code>: liquid argon scintillation yield.</li><li><code>rand_voxel_kwargs...</code>: optional keyword arguments forwarded to <a href="#LegendOpticalFits.rand_voxel-Tuple{NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}}"><code>rand_voxel</code></a>.</li></ul><p><strong>Returns</strong></p><p>A table of <code>log(p0)</code> for each channel (columns) and event (rows).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/simulation.jl#L73-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.make_efficiencies_prior-Tuple{Any}"><a class="docstring-binding" href="#LegendOpticalFits.make_efficiencies_prior-Tuple{Any}"><code>LegendOpticalFits.make_efficiencies_prior</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_efficiencies_prior(channels)</code></pre><p>Construct a hierarchical prior for <code>channels</code> efficiencies.</p><ul><li>a global hyperprior <code>scale ~ Beta(7, 5)</code> sets the typical efficiency scale.</li><li>each channel efficiency has a Beta prior with mean <code>scale * shift</code> and concentration <code>concentration</code>, enforcing positivity and preference for lower values.</li></ul><p><strong>Arguments</strong></p><ul><li><code>channels</code>: A list of channel names.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/priors.jl#L5-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.make_λ0_likelihood-Tuple{TypedTables.Table, TypedTables.Table, TypedTables.Table}"><a class="docstring-binding" href="#LegendOpticalFits.make_λ0_likelihood-Tuple{TypedTables.Table, TypedTables.Table, TypedTables.Table}"><code>LegendOpticalFits.make_λ0_likelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">make_λ0_likelihood(x0, log_p0_nominal, x0_random_coin; multiplicity_thr=0, n_rands=10, smear_factor=0, device=CPUDevice()) -&gt; DensityFunction</code></pre><p>Construct the likelihood of no-light fractions per channel.</p><p>We model the fraction of events with no detected light (<code>λ0</code>) as follows:</p><ul><li><p>For each channel, the expected no-light probability <code>λ0_model</code> comes from the simulation (<code>log_p0_nominal</code>) combined with random coincidences (<code>x0_random_coin</code>) and scaled by per-channel efficiencies (the parameters of the model).</p></li><li><p>The observed no-light fraction in data is <code>λ0_data = N0 / N_data</code>, where <code>N0</code> is the number of no-light events passing a multiplicity threshold.</p></li><li><p>Since <code>N_data</code> is large, the binomial distribution <code>N0 ~ Binomial(N_data, λ0_model)</code> can be approximated by a normal distribution: <code>λ0_data ~ Normal(μ = λ0_model, σ² = λ0_model (1 - λ0_model) / N_data)</code>.</p></li></ul><p>The likelihood is the sum of log-probabilities across all channels.</p><p><strong>Arguments</strong></p><ul><li><code>x0</code>: observed no-light indicators from data events.</li><li><code>log_p0_nominal</code>: logarithm of the probability to see no light for each (event, channel), typically from simulations.</li><li><code>x0_random_coin</code>: observed no-light indicators from random coincidence events.</li><li><code>multiplicity_thr</code>: discard events with multiplicity below this threshold (optional, defaults to 0).</li><li><code>n_rands</code>: average forward model results over this amount of random numbers.</li><li><code>smear_factor</code>: the width of the likelihood gaussian terms is increased by a factor <code>smear_factor * mean</code>.</li><li><code>device</code>: on which device to run the computation of the forward model. (default <code>CPUDevice()</code>)</li></ul><p><strong>Examples</strong></p><p>Get some data:</p><pre><code class="language-julia hljs">using LegendOpticalFits

runsel = (:p13, :r001)
nev_sim = 10_000
nev_data = 1_000
multiplicity_thr = 6

optmap = load_optical_map(&quot;./optmap-p13.lh5&quot;, runsel)
log_p0 = log_p0_nominal_ar39(optmap, nev_sim)

x0 = x0_data(&quot;l200-p13-r001-ath-tier_evt.lh5&quot;, runsel, max_events=nev_data)
x0_rc = x0_data(&quot;l200-p13-r001-ant-tier_evt.lh5&quot;, runsel, max_events=nev_sim)</code></pre><p>Build the likelihood (on the CPU by default):</p><pre><code class="language-julia hljs">logl = make_λ0_likelihood(x0, lp0, x0_rc, multiplicity_thr=multiplicity_thr)</code></pre><p>CUDA via Reactant/XLA:</p><pre><code class="language-julia hljs">using Reactant
Reactant.set_default_backend(&quot;cuda&quot;)

logl = make_λ0_likelihood(x0, lp0, x0_rc, multiplicity_thr=multiplicity_thr, device=ReactantDevice())</code></pre><p><strong>Returns</strong></p><ul><li>A <code>DensityFunction</code> object representing the log-likelihood. It can be called with a parameter set.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/likelihood.jl#L1-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.rand_voxel-Tuple{NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}}"><a class="docstring-binding" href="#LegendOpticalFits.rand_voxel-Tuple{NamedTuple{names, T} where {names, T&lt;:Tuple{Vararg{StatsBase.Histogram{&lt;:AbstractFloat, 3}}}}}"><code>LegendOpticalFits.rand_voxel</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rand_voxel(optmap::OpticalMap; xrange = nothing, yrange = nothing, zrange = nothing) -&gt; (ix, iy, iz)</code></pre><p>Sample a random valid voxel (bin indices) from an <code>OpticalMap</code>.</p><p>The function draws random voxel indices <code>(ix, iy, iz)</code> within the histogram domain of the optical map. The histogram of the first channel is used to determine the geometry (all channels share the same dimensions).</p><p><strong>Arguments</strong></p><ul><li><code>optmap</code>: optical map (see <a href="#LegendOpticalFits.load_optical_map-Tuple{AbstractString, Tuple{LegendDataManagement.DataPeriodLike, Union{LegendDataManagement.DataRun, AbstractString, Symbol}}}"><code>load_optical_map</code></a>.</li><li><code>xrange</code>, <code>yrange</code>, <code>zrange</code>: optional <code>(min,max)</code> in axis units.   If <code>nothing</code> (default), the full axis range is used.</li></ul><p><strong>Returns</strong></p><p>Tuple <code>(ix, iy, iz)</code> of voxel indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/optmap.jl#L86-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.x0_data-Tuple{AbstractString, Tuple{LegendDataManagement.DataPeriodLike, Union{LegendDataManagement.DataRun, AbstractString, Symbol}}}"><a class="docstring-binding" href="#LegendOpticalFits.x0_data-Tuple{AbstractString, Tuple{LegendDataManagement.DataPeriodLike, Union{LegendDataManagement.DataRun, AbstractString, Symbol}}}"><code>LegendOpticalFits.x0_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">x0_data(filename, runsel; ...) -&gt; Table</code></pre><p>Load <code>x0</code> values from LEGEND-200 SiPM data.</p><p>For each event and channel, this function records whether no photon above the high photoelectron threshold was detected within the <code>[-1, 5] μs</code> coincidence window. The output is a <code>Table</code> where each column corresponds to a SiPM channel and each row to an event.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: path to the <em>pygama</em> LH5 file containing event-tier data.</li><li><code>runsel</code>: <code>(period, run)</code> identifier, used to select the proper channel map.</li><li><code>max_events</code>: (optional) maximum number of events to read, default <code>10_000</code>.</li></ul><p><strong>Returns</strong></p><p>a <code>Table</code> of booleans with dimensions <code>(max_events, n_channels)</code>. each entry is <code>true</code> if no qualifying photon was observed, <code>false</code> otherwise.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">x0_data(&quot;l200-p13-r003-anp-20241217T094846Z-tier_evt.lh5&quot;, (:p13, :r003))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/data.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.x0_mock-Tuple{NamedTuple, TypedTables.Table, TypedTables.Table}"><a class="docstring-binding" href="#LegendOpticalFits.x0_mock-Tuple{NamedTuple, TypedTables.Table, TypedTables.Table}"><code>LegendOpticalFits.x0_mock</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">x0_mock(efficiencies_true, log_p0_nominal, x0_random_coin)</code></pre><p>Generate mock x0 data (bernoulli draws folded with random-coincidence mask) from <code>efficiencies_true</code> and <code>log_p0_nominal</code> from model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/mock.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.λ0_data-Tuple{TypedTables.Table}"><a class="docstring-binding" href="#LegendOpticalFits.λ0_data-Tuple{TypedTables.Table}"><code>LegendOpticalFits.λ0_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">λ0_data(x0; multiplicity_thr=0) -&gt; NamedTuple</code></pre><p>Compute per–channel no-light fractions from a boolean <code>Table</code> of events.</p><p><strong>Arguments</strong></p><ul><li><code>x0</code>: a <code>Table</code> where each column corresponds to a channel and each row to an event; entries are <code>Bool</code> indicating whether no qualifying photon was observed in the channel.</li><li><code>multiplicity_thr</code>: minimum number of channels with light per event required for the event to be considered. Defaults to <code>0</code>.</li></ul><p><strong>Returns</strong></p><p>A <code>NamedTuple</code> with one field per channel containing the fraction of selected events in which that channel had no light, and the total number of events passing the multiplicity threshold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/data.jl#L84-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LegendOpticalFits.λ0_model-Tuple{NamedTuple, TypedTables.Table, TypedTables.Table}"><a class="docstring-binding" href="#LegendOpticalFits.λ0_model-Tuple{NamedTuple, TypedTables.Table, TypedTables.Table}"><code>LegendOpticalFits.λ0_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">λ0_model(efficiencies, log_p0_nominal, x0_random_coin[, multiplicity_thr])</code></pre><p>Expected fraction of events in which a SiPM channel sees no light.</p><p>Computes the expected fraction by looping over the rows (events) in <code>log_p0_nominal</code>. It samples the expected light/no-light observable by combining the probability to see no light <code>p0</code> with the random coincidence data (at the same row index). If a multiplicity threshold is specified, events with lower multiplicity are discarded.</p><p><strong>Arguments</strong></p><p>All input data is keyed by detector name (a symbol)</p><ul><li><code>efficiencies</code>: scaling factors for each SiPM channel.</li><li><code>log_p0_nominal</code>: logarithm of the probability to see no light for each (event, channel), typically from simulations.</li><li><code>x0_random_coin</code>: presence of light from random coincidences for each (event, channel). This is typically coming from a measurement.</li><li><code>multiplicity_thr</code>: discard events with multiplicity below this threshold (optional, defaults to 0).</li><li><code>n_rands</code>: average forward model results over this amount of random numbers.</li></ul><p><strong>Returns</strong></p><ul><li>Vector of expectation values for each channel, ordered as the input data structures.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/legend-exp/LegendOpticalFits.jl/blob/6ded57a7513d84649a78d30044455c9cb36fb2a9/src/models.jl#L1-L27">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../LICENSE/">LICENSE »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 1 December 2025 14:31">Monday 1 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
